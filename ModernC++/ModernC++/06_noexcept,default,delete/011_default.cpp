//특수 멤버 함수들의 자동 작성 조건을 숙지하라 ---------------------------------------------------------

//특수 멤버 함수
//  컴파일러가 스스로 작성할 수 있는 멤버 함수들, 
//  즉, 기본 생성자와 소멸자, 복사 연산들, 이동 연산들을 가리켜 '특수멤버함수' 라고 부른다.
// 
//  생성자 (Constructor) 
//  소멸자 (Destructor) 
//  복사 생성자 (Copy Constructor) 
//  복사 할당자 (Copy Assignment) 
//  이동 생성자 (Move Constructor) 
//  이동 할당자 (Move Assignment)

//기본 생성자
//  - 사용자 선언 생성자가 없는 경우에만 자동으로 작성
//소멸자
//  - 기반 클래스 소멸자가 가상일 때에만 가상이다, 소멸자가 기본적으로 noexcept (C++11)

//복사 생성자
//  - 비정적 데이터 멤버들을 멤버별로 
//    복사 생성, 사용자 선언 복사 생성자가 없을 때에만 자동으로 작성, 
//    사용자 선언 복사 대입 연산자나 소멸자가 있는 클래스에서 이 함수가 자동 작성되는 기능은 비권장
//복사 대입 연산자 
//  - 비정적 데이터 멤버들을 멤버별로 
//    복사 대입, 사용자 선언 복사 연산자가 없을 때에만 자동, 복사 생성자 만들면 같이 작성 권장

//이동 생성자     
//  - 비정적 데이터 멤버의 멤버별 
//    이동 생성, 사용자 선언 복사 연산들과 이동 연산들, 소멸자가 없을 때에만 작성된다
//이동 대입 연산자 
//  - 비정적 데이터 멤버의 멤버별 
//    이동 대입, 사용자 선언 복사 연산들과 이동 연산들, 소멸자가 없을 때에만 작성된다


//3의 법칙(Rule of Three)
//      만일, 클래스 설계 시 복사 생성자와 복사 연산자, 소멸자 중 하나라도 선언했다면 모두 선언해야 한다.

//5의 법칙(Rule of Five)
//      C++11에는 소멸자, 복사 생성자, 복사 할당자, 이동 생성자, 이동 할당자
//      다섯 중 하나라도 사용자가 직접 구현한다면 나머지 넷도 모두 구현하는 것이 좋다.


//C++ 11 자동생성 총정리 ***
//
//default 생성자 : 
//          생성자 정의하면 자동 생성 안된다. C++ 98과 동일
//소멸자 : 
//          부모가 virtual이면 자식도 virtual로 자동 생성. 정의하면 자동생성 안된다. 여기까지 C++ 98과 동일,
//          C++ 11부터 바뀐점은 자동 생성된 소멸자가 noexcept로 만들어진다는 점. 
//copy 연산자들 : 
//          해당 함수가 선언되지 않았을 때, move 연산자들이 정의되지 않았을 때 자동 생성된다. (C++ 11) ***
//          다른 copy 연산자나, 소멸자가 있는 경우 자동 생성하는 것이 deprecated 되었다.
//          비정적 멤버들에 대해서 해당 복사 연산자를 호출하는 방식으로 동작한다.
//move 연산자들 : 
//          copy 연산자들, move 연산자들, 소멸자 모두가 정의되지 않았을 경우에만 자동 생성한다. (C++ 11) ***
//          비정적 멤버들에 대해서 move 연산자를 호출하는 방식으로 동작한다.


//C++11: 이동 생성자, 이동 연산자 추가
//이동 연산 자동 작성 조건
//      클래스에 어떤 복사 연산도 선언되어 있지 않다.
//      클래스에 어떤 이동 연산도 선언되어 있지 않다.
//      클래스에 소멸자가 선언되어 있지 않다.


// 다음과 같은 코드를 작성한 경우 //이동 연산이 되는가 ? --------------------------------------

#include <iostream>

class StringTable {
public:
    //StringTable(void) {}  // 삽입, 삭제, 조회 등을 위한 함수들은 있지만 // 복사/이동/소멸자 기능성은 없음
    StringTable(void) { print("Create"); }
    ~StringTable(void) { print("Destroy"); }     // 소멸자 추가됨  
private:
    std::map<int, std::string> values;
};

int main()
{
    return 0;
}

//이동 연산들은 
//  이동, 복사, 소멸자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성된다.
//  즉, 이동 연산이 일어나야 할 시점에 대신 복사 연산이 일어나서 효율이 심각하게 떨어질 수 있다.



//기본 연산 활성화 ------------------------------------------------------------------------
// 
//      C++11에서는 명시적으로 선언된 특수 멤버 함수가 기본 행동을 사용하겠다는 의사를 
//	    = default 를 이용해서 명시적으로 표현할 수 있다.

class Widget {
public:
   ~Widget(void);                                   // 사용자 선언 소멸자                                              
    Widget(const Widget&) = default;                // 기본 복사 생성자 // 기본 행동 OK
    Widget& operator=(const Widget&) = default;     // 기본 복사 대입  // 기본 행동 OK
};

//파생 클래스 객체들을 조작하는 데 쓰이는 인터페이스를 정의하는 클래스에 유용.
//상속 시 소멸자의 경우 
//부모 클래스가 가상(virtual)일 경우 자식 클래스도 가상(virtual)으로 자동 생성된다.

class Base {
public:
    virtual ~Base(void) = default;                  // 소멸자를 가상으로
    Base(const Base&) = default;                    // 복사 지원
    Base& operator=(const Base&) = default;
    Base(Base&&) = default;                         // 이동 지원
    Base& operator=(Base&&) = default;
};


//----------------------------------------------------------------------------------
// 멤버 함수 템플릿이 존재하면, 
// 특수 멤버 함수의 자동 작성이 비활성화된다는 규칙은 없음을 주목. ***

// 다음과 같은 Widget 클래스가 있다고 하자.

class Widget {
public:

    template <typename T>                    // 그 어떤 것으로도 Widget을 생성
    Widget(const T& rhs);                    

    template <typename T>                    // 그 어떤 것으로도 Widget을 대입    
    Widget& operator=(const Widget& rhs);    
};

// 이 템플릿들이 복사 생성자나 복사 대입 연산자의 시그니처와 일치하는 함수들로 인스턴스화될 가능성이 있지만,
// 그래도 컴파일러는 여전히 Widget의 복사 연산들과 이동 연산들을 작성한다. ( 조건이 만족되었다면 )
