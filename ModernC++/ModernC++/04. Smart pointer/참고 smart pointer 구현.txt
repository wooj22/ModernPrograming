//unique_ptr, shared_ptr 구현하기

-----------------------------------------------------------------------------------------------------
template<typename T>
class UniquePointerClone
{
public:
	T* pointer;
	UniquePointerClone(T* object): pointer(object){}
	~UniquePointerClone() { if(pointer != nullptr) delete pointer; }
	UniquePointerClone(const UniquePointerClone& other) = delete;
	UniquePointerClone& operator = (const UniquePointerClone& other) = delete;
	UniquePointerClone(UniquePointerClone&& other)
	{
		this->pointer = other.pointer;
		other.pointer = nullptr;
	}
	UniquePointerClone& operator = (UniquePointerClone&& other)
	{
		this->pointer = other.pointer;
		other.pointer = nullptr;
		return *this;
	}
};

template <typename T, typename... Args>
UniquePointerClone<T> MakeUnique(Args... args)
{
	return UniquePointerClone<T>(new T(args...));
}

-----------------------------------------------------------------------------------------------------

[ shared_ptr.h]

#pragma once

template <typename T>
class MyShared_ptr
{
public:
	MyShared_ptr(T* object) : pointer(object), referenceCount(new int(1)) {}
	~MyShared_ptr()
	{
		if (!--(*referenceCount))	
		{
			delete pointer;
			delete referenceCount;
		}
	}

	// 복사 생성자 - 얕은 복사 
	MyShared_ptr(const MyShared_ptr& other)
	{
		this->pointer = other.pointer;
		this->referenceCount = other.referenceCount;
		(*referenceCount)++;
	}

	MyShared_ptr& operator = (const MyShared_ptr& other)
	{
		this->pointer = other.pointer;
		this->referenceCount = other.referenceCount;
		(*referenceCount)++;
		
		return *this;
	}

	int GetReferenceCount() { return *referenceCount; }
	
public:
	T* pointer;
	int* referenceCount;
};
[메인]

#include <iostream>
#include <memory>
#include "MyShared_ptr.h"

using namespace std;

int main()
{
	MyShared_ptr<int> shared_ptr1(new int(0));
	MyShared_ptr<int> shared_ptr2 = shared_ptr1;
	int count = shared_ptr1.GetReferenceCount();

	cout << count << endl;

	{
		MyShared_ptr<int> shared_ptr3 = shared_ptr2;

		int count2 = shared_ptr3.GetReferenceCount();
		cout << count2 << endl;
	}

	int count3 = shared_ptr2.GetReferenceCount();
	cout << count3 << endl;

	return 0;
}

-----------------------------------------------------------------------------------------------------

[ shared_ptr.h ] 

#pragma once

template <typename TYPE>
class eb_shared_ptr
{
public:
	eb_shared_ptr() ;
	explicit eb_shared_ptr(TYPE* ptr) ;
	eb_shared_ptr(const eb_shared_ptr<TYPE>& rhs) ;
	~eb_shared_ptr() ;

	void set(TYPE* ptr) noexcept;
	TYPE* get() const noexcept { return _ptr; };
	int   use_count() const noexcept { return (*_refCount); };
	bool  unique() const noexcept { return { _refCount ? (*_refCount == 0) : false}; }

	TYPE* operator->() { return _ptr; };
	TYPE& operator* () { return *_ptr; };
	operator bool() const { return (nullptr != _refCount); }
	eb_shared_ptr<TYPE>& operator=(const eb_shared_ptr<TYPE>& rhs);
    
private:
	void addRef() noexcept;
	void release() noexcept;

private:
	int* _refCount;
	TYPE* _ptr;
};

[ shared_ptr.hpp ] 

#include "eb_shared_ptr.h"

template<typename TYPE>
eb_shared_ptr<TYPE>::eb_shared_ptr() 
	: _refCount(nullptr)
	, _ptr(nullptr)
{
}

template<typename TYPE>
eb_shared_ptr<TYPE>::eb_shared_ptr(TYPE* ptr) 
	: _refCount(nullptr)
	, _ptr(ptr)
{
	addRef();
}

template<typename TYPE>
 eb_shared_ptr<TYPE>::eb_shared_ptr(const eb_shared_ptr<TYPE>& rhs) 
	: _refCount(rhs._refCount)
	, _ptr(rhs._ptr)
{
	addRef();
}

template<typename TYPE>
eb_shared_ptr<TYPE>::~eb_shared_ptr() 
{
	release();
}

template<typename TYPE>
void eb_shared_ptr<TYPE>::addRef() noexcept
{
	if (nullptr == _refCount)
	{
		_refCount = new int(0);
	}

	(*_refCount)++;
}

template<typename TYPE>
void eb_shared_ptr<TYPE>::release() noexcept
{
	if (0 == --(*_refCount))
	{
		delete _refCount;
		delete _ptr;
	}
}

template<typename TYPE>
void eb_shared_ptr<TYPE>::set(TYPE* ptr) noexcept
{
	//원래 있던 객체 해제
	if (_refCount)
	{
		release();

		_refCount = nullptr;
		_ptr = nullptr;
	}

	addRef();
	_ptr = ptr;
}

template<typename TYPE>
eb_shared_ptr<TYPE>& eb_shared_ptr<TYPE>::operator=(const eb_shared_ptr<TYPE>& rhs) 
{
	_refCount = rhs._refCount;
	_ptr = rhs._ptr;

	addRef();
}

[ main ] 

using namespace std;
int main(void)
{
	eb_shared_ptr<int> shared1(new int(0));
	eb_shared_ptr<int> shared2 = shared1;
	int count = shared1.use_count();

	cout << count << endl;

	{
		eb_shared_ptr<int> shared3 = shared2;

		int count2 = shared3.use_count();
		cout << count2 << endl;
	}

	int count3 = shared2.use_count();
	cout << count3 << endl;

	return 0;
}
