
C++ 효율적인 메모리 관리

	메모리를 직접 제어할 수 있는 만큼 메모리 관리의 중요성이 매우 크다.
	효율적인 메모리 관리는 프로그램의 성능과 안정성을 높이며, 
	메모리 누수, 더블 프리, 접근 오류 등 치명적인 버그를 예방할 수 있다.


1. 기본적인 동적 할당 및 해제

new와 delete: C++에서는 타입 안전성을 제공하는 new와 delete를 사용한다.
배열 할당/해제: new[]와 delete[]를 사용한다.
예외 처리: try-catch 블록과 함께 RAII를 사용해 예외 상황에서도 메모리 누수를 방지한다


2. RAII(Resource Acquisition Is Initialization)

RAII 패턴: 리소스(메모리, 파일 등)를 객체의 수명과 결합해 예외 발생 시에도 안전하게 해제한다.
복사 생성자/복사 할당 연산자/소멸자: 'The Big Three'로 자원 관리의 안전성을 높인다


3. 동적 할당 최적화

객체 재사용: 불필요한 할당/해제를 피하고, 생성된 객체를 재활용한다.
메모리 풀(Memory Pool): 미리 할당된 블록을 재사용해 동적 할당 비용을 줄인다.
STL 컨테이너 활용: std::vector, std::string 등은 내부적으로 메모리를 자동 관리한다.


4. 스마트 포인터 사용

스마트 포인터는 C++11부터 도입된 기능으로, 메모리 관리를 자동화하여 코드의 안전성과 효율성을 크게 높인다

std::unique_ptr	단일 소유권. 이동만 가능, 복사 불가. 자동 해제
std::shared_ptr	공유 소유권. 참조 카운트로 관리. 마지막에 해제
std::weak_ptr	shared_ptr와 함께 사용. 순환 참조 방지


5. 복사 줄이기 및 이동 의미론 활용

참조(Reference) 사용: 함수 인자로 값을 전달할 때 참조를 사용해 불필요한 복사를 줄인다.
이동 의미론(Move Semantics): std::move를 활용해 불필요한 복사를 피하고 성능을 향상시킨다.

