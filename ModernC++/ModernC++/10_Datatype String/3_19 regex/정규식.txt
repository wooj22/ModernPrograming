https://blog.naver.com/oyh951416/222019512322

정규식은 정규식 문법이 따로 존재하는데, 
C++에서 기본은 ECMAScrpit를 따른다. 
다른 문법으로는 유닉스 사용자에겐 익숙할 grep이나, basic, egrep 등이 있다.

 regex re("",std::regex::grep);

문법 외에도 특정 플래그를 적용시킬 수도 있다. 
플래그에는 대소문자를 구분하지 않는 icase나 정규식과 일치하는 것을 무시하는 nosubs 등이 있다.

 std::regex re("",std::regex::grep | std::regex::nosubs);



2. 메타 문자

위와 같이 정규표현식에서 어떤 특정한 의미를 가지고 있는 특수문자들을 "메타 문자" 라고 한다.

  1. [ ] : 문자의 집합을 나타내며. 이 [] 안에 들어간 문자에 해당하는 문자 하나를 찾는다. 
          또한 - 를 통해 범위, ^를 통해 not을 표시 할 수 있다.

[a-z]		a부터 z까지의 문자 하나
[A-Z0-9]		A부터 Z까지나 0부터 9까지의 문자 하나
[^B-F2]		B부터 F까지나 2가 '아닌' 문자 하나

  여기서 ^는 []안에서 맨 앞에 와야한다. 만약 중간에 쓴다면 그냥 메타 문자가 아닌 그냥 글자로 판단한다.

[3^2]		3이나 ^나 2 중 문자 하나
​

  2. { } : 앞 문자의 개수

{3}		앞 문자가 3개
{2,5}		앞 문자가 2개 이상 5개 이하
{1,}		앞 문자가 1개 이상


  3. ( ) : 그룹화. 서브 패턴을 정의할 때 사용된다.

  4. ? : 앞 문자가 없거나 1개 있음

A?Z		Z, AZ

  5. * : 앞의 문자가 0개 이상. {0,}과 동일

AB*Z

AZ, ABZ, ABBBBBBZ 등

  6. + : 앞의 문자가 1개 이상. {1,}과 동일

AB+Z		ABZ, ABBBBBBZ 등
[a-z]+		a부터 z까지의 문자가 1개 이상

  7. .(dot) : 임의의 문자 1개

A.Z		ABC, AbC, A0Z 등

  8. |  : or

abc|ABC		abc 또는 ABC

  9. ^, $ : 문자열의 시작, 끝

  10. 이스케이프 시퀀스들

\s		공백(스페이스바, 탭 등)
\b		문자와 공백 사이 ex) a\b => a 다음 공백이 오는 경우
\d		숫자를 의미. [0-9]와 동일
\w		영문자, 숫자, _(언더바)를 의미. [0-9a-zA-Z_]와 동일

  만약 이스케이프 다음 영문자를 대문자로 적으면 역이 된다. (예를 들어, \D는 숫자를 제외한 문자) 아래는 \W를 사용한 경우다.
  만약 메타 문자에 해당하는 문자를 찾고 싶은 거라면 어떻게 해야될까? 예를 들어, 문자열에 []가 있는 부분을 찾고 싶은 것이라면 해당 문자 앞에 \를 붙여주면 된다.

  이제 아까 정규식을 다시 봐보자
    regex re("Log_\\[[0-9]{6}\\]_\\(\\d{6}\\)_server[^2]+\\.txt");
  이걸 위의 메타 문자에 맞춰 해석하면 다음과 같다.
    'Log_[' 다음 6자리 숫자가 오고 그 다음으론 ']_(' 와 6자리 숫자 그리고 ')_server'가 온다. 그 뒤론 2를 제외한 문자가 온 다음 .txt가 와야된다. 
  여기서 메타 문자에 \를 두 번씩 쓴 이유는 한 번만 쓰면 \n(개행)같은 C언어의 이스케이프 시퀀스로 인식하기 때문이다. \를 출력하려면 \\를 써야되는 것과 같다.



3. 정규식 함수

이제 C++에서 이 정규식을 활용할 수 있는 방법에 대해 알아보자. C++ regex에 있는 함수에는 다음과 같은 것들이 있다.

  regex_match(str, match, re) : str이 정규식 re와 완전히 일치하면 true를 return하고 match에 일치한 부분을 저장한다.
  regex_search(str, match, re) : str에 re와 일치하는 부분이 있는지 찾고, 있으면 true를 return하면서 match에 일치한 부분을 저장한다.
  regex_replace(str, re, format) : str에 re와 일치하는 부분들을 format으로 치환한다.


#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <iomanip>

using namespace std;
int main() {
	regex re("(0+[0-7]{1,2})+[\\s\\)-]?([\\d]{3,4})+[\\s-]?([\\d]{4})");
	smatch m;
	vector<string> phone_list = { "02)1234-5678", "010-1212-3434", "03112349876",
								  "0312223333", "011 789-6543", "064 123-4567",
								  "12 1234 5678", "02)12-3456", "010)1234 567",
								  "070-1588-1588",
								  "My Phone number is 010-1111-2222." };
	for (string s : phone_list) {
		cout.setf(ios::left);
		cout << setw(14) << s;
		if(regex_match(s, m, re))
		 cout << " " << setw(15) << "MATCH!"<< setw(14) << m.str() <<'\n';
		
		else cout << " " << setw(15) << "MISS MATCH!" << '\n';
	}
	return 0;
}


#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <iomanip>

using namespace std;
int main() {
	regex re("(0+[0-7]{1,2})+[\\s\\)-]?([\\d]{3,4})+[\\s-]?([\\d]{4})");
	smatch m;
	vector<string> phone_list = { "02)1234-5678", "010-1212-3434", "03112349876",
								  "0312223333", "011 789-6543", "064 123-4567",
								  "12 1234 5678", "02)12-3456", "010)1234 567",
								  "070-1588-1588",
								  "My Phone number is 010-1111-2222." };
	for (string s : phone_list) {
		cout.setf(ios::left);
		cout << setw(14) << s;
		if(regex_search(s, m, re))
		 cout << " " << setw(15) << "MATCH!"<< setw(14) << m.str() <<'\n';
		
		else cout << " " << setw(15) << "MISS MATCH!" << '\n';
	}

	return 0;
}


#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <iomanip>

using namespace std;
int main() {
	regex re("(0+[0-7]{1,2})+[\\s\\)-]?([\\d]{3,4})+[\\s-]?([\\d]{4})");
	smatch match;
	string str = "My Phone number is 010-1111-2222. OK?";
	regex_search(str, match, re);
	cout << "앞부분 : " << match.prefix() << '\n';
	cout << "일  치 : " << match.str() << '\n';
	cout << "뒷부분 : " << match.suffix() << '\n';
		
		
	return 0;
}


#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <iomanip>

using namespace std;
int main() {
	regex re("(0+[0-7]{1,2})+[\\s\\)-]?([\\d]{3,4})+[\\s-]?([\\d]{4})");
	smatch match;
	string str = "My Phone number is 010-1111-2222. OK?";
	regex_search(str, match, re);
	cout << "일치 전체 부분	: " << match[0].str() << '\n';
	cout << "첫 그룹		: " << match[1].str() << '\n';
	cout << "두번째 그룹	: " << match[2].str() << '\n';
	cout << "마지막 그룹	: " << match[3].str() << '\n';
	return 0;
}


#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <iomanip>

using namespace std;
int main() {
	vector<string> phone_list = { "02)1234-5678", "010-1212-3434", "03112349876",
							  "0312223333", "011 789-6543", "064 123-4567",
							  "12 1234 5678", "02)12-3456", "010)1234 567",
							  "070-1588-1588" };
	regex re("(0+[0-7]{1,2})+[\\s\\)-]?([\\d]{3,4})+[\\s-]?([\\d]{4})");
	smatch match;

	cout.setf(ios::left);
	cout << setw(12) << "구 분" << " " << setw(10) << "국 번"
		<< setw(12) << "앞자리" << setw(12) << "뒷자리" << '\n';
	for (string str : phone_list) {
		regex_search(str, match, re);
		if (match.size() > 0) {
			if (match[1].str().substr(0, 2) == "01") {
				cout << setw(12) << "핸드폰";
			}
			else if (match[1].str().substr(0, 2) == "07") {
				cout << setw(12) << "인터넷전화";
			}
			else {
				cout << setw(12) << "일반전화";
			}
			cout << " " << setw(10) << match[1].str() << setw(12) << match[2].str()
				<< setw(12) << match[3].str() << '\n';
		}

	}
	return 0;
}


#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <iomanip>

using namespace std;
int main() {
	string phone_num = { "02)1234-5678 010-1212-3434 12 3456 7890 03112349876",};
	regex re("(0+[0-7]{1,2})+[\\s\\)-]?([\\d]{3,4})+[\\s-]?([\\d]{4})");
	smatch match;

	cout << phone_num << '\n';
	string temp = regex_replace(phone_num, re, "전화번호");
	cout << temp << '\n';

	return 0;
}


#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <iomanip>

using namespace std;
int main() {
	string phone_num = { "02)1234-5678 010-1212-3434 12 3456 7890 03112349876",};
	regex re("(0+[0-7]{1,2})+[\\s\\)-]?([\\d]{3,4})+[\\s-]?([\\d]{4})");
	smatch match;

	cout << phone_num << '\n';
	string temp = regex_replace(phone_num, re, "전화번호", regex_constants::format_first_only);
	cout << temp << '\n';

	return 0;
}


#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <iomanip>

using namespace std;
int main() {
	string phone_num =  "02)1234-5678 010-1212-3434 12 3456 7890 03112349876";
	regex re("(0+[0-7]{1,2})+[\\s\\)-]?([\\d]{3,4})+[\\s-]?([\\d]{4})");
	smatch match;
	
	cout << phone_num;
	string temp = regex_replace(phone_num, re, "전화번호", regex_constants::format_no_copy);
	cout << temp;

	return 0;
}


#include <iostream>
#include <string>
#include <vector>
#include <regex>
#include <iomanip>

using namespace std;
int main() {
	string phone_num =  "02)1234-5678 010-1212-3434 12 3456 7890 03112349876";
	regex re("(0+[0-7]{1,2})+[\\s\\)-]?([\\d]{3,4})+[\\s-]?([\\d]{4})");
	smatch match;
	
	cout << phone_num << '\n';
	string temp = regex_replace(phone_num, re, "전화번호",
                  regex_constants::format_no_copy | regex_constants::format_first_only);
	cout << temp << '\n';

	return 0;
}

참고로 flag 중에 format_ 으로 시작하는 flag들은 regex_replace()에서만 의미있는 것으로 보인다. match나 search에도 사용은 가능하나 변화가 없는 것으로 보인다.






