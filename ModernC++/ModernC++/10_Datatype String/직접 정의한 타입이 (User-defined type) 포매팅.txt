

//직접 정의한 타입이 (User-defined type) 포매팅에 사용되려면 두 가지 방법 --------------------
//  (펑소처럼)std::ostream에 operator<< 재정의 해서 사용하기
//  UDT에 대한 사용자 정의 포매터 (User-defined formatter) 작성

//(펑소처럼) std::ostream에 operator<< 재정의 해서 사용하기

    #include <iostream>
    #include <format>

    enum class State {
        On,
        Off
    };

    std::ostream& operator<<(std::ostream& os, const State state) {
        switch (state) {
        case State::On:     return os << "On";
        case State::Off:    return os << "Off";
        }
        return os;
    }

    int main()
    {
        std::cout << State::On;

        //const std::string current_mode = std::format("current mode is {}", State::On);
    }

//UDT에 대한 사용자 정의 포매터 (User-defined formatter) 작성 --------------------------------------------

//사용자 정의 포매터를 작성하려면 
// 유형에 맞는 std::formatter 를 특수화, 특수화에는 두 개의 멤버 함수가 포함
// 
//parse(context) : replacement field(placeholder)가 있는 경우 타입을 구문 분석하는 역할을 합니다.
//  즉, 타입 문자열의 "{}" 내부에 있는 내용을 구문 분석하는 함수입니다.
//  만약 replacement field가 발견되면 std::formatter 객체에 저장해야 합니다. (this 함수 context 에서)
//
//format(value, context) : parse()에서 찾은 타입 사양을 적용하여 formatting context에 제공(내보내야) 합니다.
//
//std::format_to()에서 제공하는 반복자를 사용하여 간단히 추가할 수도 있습니다.

    #include <iostream>
    #include <format>
    using namespace std;

    struct point {
        double x, y;
    };

    template <> struct std::formatter<point> {
        // f - 부동 수숫점형,  e - 지수
        char presentation{ 'f' };

        // 'f' 또는 'e'를 분석합니다.
        constexpr auto parse(format_parse_context& ctx) -> decltype(ctx.begin()) {
            // [ctx.begin(), ctx.end())는 형식 문자열의 일부를 포함하는 문자 범위입니다.
            // 예를 들어 std::format("{:f} - point of interest", point{1, 2}); 라면
            // 범위에는 "f} - point of interest" 가 포함됩니다.
            // 포매터는 '}' 또는 범위의 끝까지 지정자를 구문 분석해야 합니다.
            // 이 예에서 포매터는 'f' 지정자를 구문 분석하고 '}'를 가리키는 반복자를 반환해야 합니다.

            auto it{ ctx.begin() };
            auto end{ ctx.end() };

            if (it != end && (*it == 'f' || *it == 'e')) presentation = *it++;
            if (it != end && *it != '}') throw std::format_error("invalid format");

            return it;
        }

        // 구분 분석 특수화를 사용하여 p의 타입을 지정합니다.
        // 이 포매터에 저장됩니다.
        template <typename FormatContext>
        auto format(const point& p, FormatContext& ctx) -> decltype(ctx.out()) {
            // ctx.out() 는 쓰기(write)에 사용된 output iterator 입니다.
            return presentation == 'f'
                ? format_to(ctx.out(), "({:.1f}, {:.1f})", p.x, p.y)
                : format_to(ctx.out(), "({:.1e}, {:.1e})", p.x, p.y);
        }
    };
    int main()
    {
        point p{ 1, 2 };
        std::string s{ std::format("{:f}", p) };
        // s == "(1.0, 2.0)"
    }


//상속 또는 구성(composition)을 통해 기존 포매터를 재사용할 수도 있습니다. --------------------------------
//예를 들어 

    #include <iostream>
    #include <format>
    using namespace std;

    enum class color { red, green, blue };

    template <> struct std::formatter<color> : formatter<string_view> {
        // formatter<string_view>를 상속받아 분석합니다.
        template <typename FormatContext>
        auto format(color c, FormatContext& ctx) {
            string_view name = "unknown";
            switch (c) {
            case color::red:   name = "red"; break;
            case color::green: name = "green"; break;
            case color::blue:  name = "blue"; break;
            }
            return formatter<string_view>::format(name, ctx);
        }
    };

    int main()
    {
        //parse는 상속됐기 때문에 formatter<string_view>로 인해 모든 문자열 타입 사양을 인식합니다.
        std::format("{:>10}", color::blue);
        //"          blue"
    }

//클래스 계층에 대한 포매터를 작성할 수도 있습니다.

    #include <type_traits>
    #include <iostream>
    #include <format>
    using namespace std;

    struct A {
        virtual ~A() {}
        virtual std::string name() const { return "A"; }
    };

    struct B : A {
        virtual std::string name() const { return "B"; }
    };

    template <typename T>
    struct std::formatter<T, std::enable_if_t<std::is_base_of<A, T>::value, char>> :
        std::formatter<std::string> 
    {
        template <typename FormatCtx>
        auto format(const A& a, FormatCtx& ctx) {
            return std::formatter<std::string>::format(a.name(), ctx);
        }
    };

    int main() {
        B b;
        A& a = b;
        std::format("{}", a); // "B"
    }

//formatter가 분석 가능한 타입에 대한 특수화 및 암시적 변환을 모두 제공할 경우, 특수화가 우선시 됩니다.