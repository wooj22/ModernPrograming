// volatile			
//		휘발성, 값을 항상 메모리에만 보관하게 하는 키워드
//      volatile 선언의 의미 : “컴파일러, 이 변수 값을 마음대로 최적화하지 마라”
//							  즉, 변수 값이 언제든 외부 요인에 의해 바뀔 수 있다는 걸 알려줌
//		C++ 컴파일러는 성능 최적화를 위해 사용하지 않는 변수 접근을 제거하거나, 반복문 안에서 변수를 캐싱할 수 있음.
//		volatile 선언하면 항상 메모리에 접근해야 하므로 컴파일러는 최적화하지 않음.

#include <iostream>
using namespace std;

int main()
{
	volatile int i = 0;		// volatile로 선언하여 항상 메모리에 접근하도록 만듦
	
	while (i < 10)			// volatile 선언하면 항상 i의 메모리에 접근해야 하므로 컴파일러는 반복문을 없애지 않음
		i++;				

	//int i = 10;			// 선언 안하면, 컴파일러는 반복문을 없애버리고 10을 할당 (Visual Studio의 /O2 옵션, GCC의 -O3 옵션)

	printf("%d\n", i);		// 10

	return 0;
}

//-----------------------------------------------

#include <iostream>
using namespace std;

void main()
{
	const int c = 5;
	//volatile const int c = 5;

	printf("%d\n", c);
	*const_cast<int*>(&c) = 8;			// const_cast로 const 속성 제거
	printf("%d\n", c);
}

/*
volatile은 변수가 언제 어느때든지 값이 바뀔수 있기 때문에, 값을 항상 메모리에만 보관하라는 의미.

일반적인 프로그래밍에서는 보통 잘 쓰이진 않지만, 
하드웨어에 관련한 프로그래밍을 하는 사람에게는 매우 중요한 키워드입니다.

간단한 예를 들어보자면.....

	똑똑한 컴파일러들은 반복문 등에서 어떤 변수의 사용이 잦을 경우에 
	자기가 알아서 자동으로 해당 변수를 registor 형으로 사용하는 경우가 있습니다.
	이렇게 해당 변수를 레지스터에 넣고 사용하다가 반복문이 끝나면 메모리로 복귀시키는 경우가 있는데..

	문제는, 프로그램이 수행되는 도중에	인터럽트에 의해서라던가 아니면 다른 쓰레드에 의해 
	해당 변수의 내용(메모리상에 있는 내용)이 바뀌는 경우가 있습니다.
	이 상황에서.	그 변수를 registor에 넣고 돌아가는 코드가 동시에 돌아가고 있다면
	그곳에서는 변수의 내용이 바뀌었는지 알아챌 수가 없겠지요.
	따라서 이로 인해 프로그램이 오작동 하거나, 큰 문제를 일으킬 수 있습니다.
	반대의 경우로서, 변수를 레지스터에 넣고 돌리는 동안에는
	다른 루틴에서 이 변수의 내용이 바뀌었는지의 여부를 알수가 없겠지요.

	이러한 상황을 방지하기 위해, 변수를 선언할 때,	volatile라는 키워드를 사용하면.
	그 변수를 참조할때 무조건 메모리상의 내용을 바탕으로 하기 때문에, 
	문제를 해결할 수가 있습니다..

	또한 memory mapped io등과 같은 곳에서도, 
	해당 메모리 번지를 '직접' 액세스하여야만 하는 것이기 때문에
	만약의 사태에 대비하여 volatile로 선언하곤 합니다.
*/