condition_variable에서 unique_lock을 써야 하는 이유


lock을 획득할 때 많이 사용하는 클래스가 lock_guard입니다. 
객체가 스코프를 벗어나서 메모리에서 사라질 때 소멸자가 호출되면서 unlock()을 호출해주기 때문에 
예외가 발생하는 상황에서도 try-catch 구문으로 잘 감싸주기만 한다면 자동으로 lock을 해제합니다. 
편한 기능이지만 lock_guard는 오직 생성자, 소멸자를 통해서만 lock을 다룰 수 있다는 제한사항이 존재합니다.

condition_variable의 좋은 점은 조건을 만족하지 않을 때 무한대기하며 CPU를 낭비하지 않고, 해당 스레드를 바로 블락해버린다는 것입니다. 
스레드가 블락되면 CPU의 제어권이 다른 스레드에게 넘어가기 때문에 CPU를 효율적으로 사용할 수 있습니다. 
wait()는 condition_variable이 통지되거나 가짜 깨우기가 일어날 때까지 블락되며 선택적으로, 조건이 참일 때까지 반복됩니다. 
깨어나면 lock을 획득하고 조건이 있으면 확인합니다. lock을 획득할 때 데이터 레이스가 일어나긴 합니다만, 
무조건적인 데이터 레이스가 아니라 notify_xxx()가 호출된 이후이기 때문에 CPU의 낭비를 최소화할 수 있습니다.

unique_lock은 lock_guard와 비슷하지만 기능이 더 많습니다. 
lock을 획득하는 시점을 미룰 수 있고 lock을 잡기 위해 무한대기를 하지 않아도 되며 데드락을 피하기 위해 락을 획득하는 순서를 보장해주는 기능도 있습니다. 
lock을 획득하는 시점을 정할 수 있고 unlock() 함수도 호출할 수 있기 때문에 condition_variable에서는 unique_lock을 써야 합니다. 
어차피 문법적으로 해당 unique_lock만 사용할 수밖에 없긴 합니다.

condition_variable의 wait() 함수는 unique_lock 객체를 하나만 넣어도 되고, 
두 번째 인자에 Predicate을 넣어줄 수도 있습니다. 조건을 넣어주면 해당 조건이 참일 때 락을 획득합니다.

void wait( std::unique_lock<std::mutex>& lock )은 원자적으로 락을 풀고, 스레드를 블록해 대기 스레드의 목록에 추가합니다. 
스레드는 notify_all()이나notify_one()이 호출되면 블락이 풀립니다. 
그냥 풀리기도 합니다(spurious wakeup, 가짜 깨우기). 무엇이 이유가 되었든 블락이 풀리면 락을 획득하고 wait() 함수가 종료됩니다.

template< class Predicate > void wait( std::unique_lock<std::mutex>& lock, Predicate pred )을 사용하는 흐름은 다음과 같습니다.

unique_lock<mutex> lock(m);
cv.wait(lock , []() {return q.empty() == false; }); // q.empty() == false면 탈출
// 1) Lock을 잡은 상태
// 2) 조건 확인
//	- 만족 O => 빠져 나와서 이어서 코드를 진행(락을 획득하고 탈출)
//	- 만족 X => Lock을 원자적으로 풀고 블락됨(wait(loci))
//		a) notify_xxx()가 호출되면 스레드가 깨어난다
//		b) lock을 다시 얻고(wait(lock), 2)부터 반복

위의 예제처럼 두 번째 인자를 넣어주는 것은 다음 코드와 같습니다. 
lock을 다시 획득한 뒤 pred를 만족하면 루프를 탈출하고 그다음 코드를 실행하는 것이지요. 
주목해야 할 점은 lock은 반드시 이 함수에 진입하기 전에 획득어야 하며 wait(lock)이 종료될 때 다시 획득된다는 것입니다. 
즉, pred()가 lock으로 보호된다는 의미입니다. unlock()은 unique_lock 객체의 소멸자를 통해 호출됩니다.

while (!pred()) 
{
    wait(lock);
}
