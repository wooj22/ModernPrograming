
spurious wakeups 란 
비정상적으로 깨어난 조건 변수 알림을 뜻합니다.

 그렇다면 왜 이런 현상이 발생할까요?

 일반적으로 condition_variable을 통해서 notify 함수를 호출 할 때 mutex의 잠금을 유지할 필요가 없습니다. 

 그렇기 때문에 아래와 같은 시나리오가 발생할 수 있습니다. 

스레드 A가 condition variable을 통해서 스레드에 안전한 queue에 데이터가 들어오길 대기합니다.
스레드 B가 queue에 데이터를 추가한 후에 mutex를 해제 한 후에 통지 알림을 보내기 전에 컨텍스트 스위치가 발생합니다. 
스레드 C가 queue에 데이터를 추가한 후에 통지 알림을 보냅니다. 
스레드 A는 통지를 전달받고 queue에 있는 2개의 데이터를 모두 처리 합니다.
스레드 B가 다시 시작되고 통지 알림을 전달합니다
스레드 A는 깨어나지만 큐가 비어 있는 상태입니다. (spurious wakeups 발생합니다.)
 다양한 이유로 해당 현상이 발생할 수 있습니다.

 정확한 통지 전달을 위해서 잠금을 유지한 상태로 통지하고 잠금을 해제 할 수도 있습니다. 

 하지만 이 방법은 통지를 전달 받은 스레드가 잠금이 해제 될 때까지 대기 할 수 있기 때문에 성능이

 떨어집니다. 

-------------------------------------------------------------------------------------------------
https://a-researcher.tistory.com/30

멀티 스레드 환경에서 동기화를 수행하려면
sender와 receiver 둘 다 condition variable의 인스턴스를 가지고 있어야 한다 (동일한 condition variable을 공유해야 함)

코드 구현은 단순한데
receiver는 wait 함수를 호출해서 notification을 기다리고 (condVar.wail(lck))
sender는 notify 함수를 호출해 receiver에게 notification을 전달한다 (condVar.notify_one())

사실 위에 설명한 내용이 condition variable을 사용하는 이유의 전부라고 할 수 있다

#include <iostream>
#include <condition_variable>
#include <mutex>
#include <thread>

std::mutex mutex_;
std::condition_variable condVar;

void doTheWork(){
  std::cout << "Processing shared data." << std::endl;
}

void waitingForWork(){
    std::cout << "Worker: Waiting for work." << std::endl;

    std::unique_lock<std::mutex> lck(mutex_);
    condVar.wait(lck);
    doTheWork();
    std::cout << "Work done." << std::endl;
}

void setDataReady(){
    std::cout << "Sender: Data is ready."  << std::endl;
    condVar.notify_one();
}

int main(){

  std::cout << std::endl;

  std::thread t1(waitingForWork);
  std::thread t2(setDataReady);

  t1.join();
  t2.join();

  std::cout << std::endl;
  
}
 

위 코드를 조금 더 설명하면 먼저 main 함수에서 t1과 t2 두 개의 스레드를 생성한다
각 스레드는 각각 호출가능한 함수인 waitingForWork와 setDataReady를 각각 인자로 받아 병렬로 실행된다

waitingForWork
	lock을 유지한 상태로 notification을 기다리고 (condVar.wait(lck))
	notification을 수신하면 doTheWork()를 수행
setDataReady
	준비가 완료되면 notify_one() 함수를 호출

짚고 가야할 것이 있는데.. 

Spurious wakeup
POSIX나 모든 OS에서 signal을 줬을때 하나만 깨어나는 것이 아니라 
동시에 여러 wait condition이 깨어나는 현상을 뜻합니다. 
이는 OS의 성능 이슈이기 때문에 개발자 영역으로 남겨져 있습니다.


Lost wakeup

receiver가 wait 함수를 호출하기도 전에 sender가 notification을 전달해버리는 경우가 발생하기 때문이다
그러면 notification은 소실되고 receiver는 영원한 대기상태에 빠진다

물론 predicate를 사용하는 것만으로도 문제를 해결하는데 도움이 될 수 있겠지만
결국 c++에서 멀티스레딩을 잘 사용하려면 task를 이용할 수 있어야 한다

-------------------------------------------------------------------------------------------------
https://github.com/CppKorea/CppConcurrencyInAction/issues/5