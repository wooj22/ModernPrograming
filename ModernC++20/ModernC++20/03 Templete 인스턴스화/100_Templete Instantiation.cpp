//템플릿 인스턴스화(template instantiation)
//      컴파일러가 함수(클래스) 틀(Template)로 부터 실제 C++ 함수(클래스)를 만들어 내는 과정
// 
//      함수가 '호출'되는 코드가 있으면 
//		컴파일러는 모든 인스턴스를 T 사용자가 지정하거나 컴파일러에서 추론하는 '구체적인 형식 인수'로 바꾼다.
//      컴파일러가 템플릿에서 클래스 또는 함수를 '생성'하는 프로세스를 템플릿 인스턴스화라고 합니다.

//암시적 구체화 (인스턴스화)
//		코드의 호출부를 보고 필요한 함수를 컴파일러가 생성한다. ***
//		호출하지 않은 타입에 대해서는 사용할 일이 없으니 함수를 만들 필요가 없다.

//명시적 구체화 (인스턴스화)
//		호출하지 않아도 미리 함수를 만들어 놓아야할 필요가 있을 때.
//		호출 여부에 상관없이 지정한 타입에 대해 함수를 만들 것을 컴파일러에게 지시하는 것. ***


//템플릿 인스턴스화, 특수화
//
//		인스턴스화된 구체화된 결과물(함수든 클래스든..)을 특수화라고 합니다.
// 
//		특수화의 경우 이렇게 인스턴스화를 통해서만이 아니라 
//		명시적 특수화, 부분 특수화를 통해서도 가능합니다.
//		보통은 템플릿의 '특수화' 라고 하면 명시적 특수화나 부분 특수화를 말합니다.

//템플릿 특수화
//
//		특정 형식에 대한 템플릿의 특수화를 정의할 수 있습니다. 
//		모든 형식 매개 변수가 특수화된 특수화는 완전한 전문화입니다.
//		일부 매개 변수만 특수화된 경우 '부분 특수화'라고 합니다.(클래스 템플릿만 가능)


//예시 //부분 특수화

	template <typename K, typename V>
	class MyMap { };

	// partial specialization for string keys
	template<typename V>
	class MyMap<string, V> { };				//K, V 중에서 K 만 특수화됨.

	int main
	{
		MyMap<int, MyClass> classes;		// uses original template
		MyMap<string, MyClass> classes2;	// uses the partial specialization
	}


//템플릿 인스턴스화 시점은
//		클래스 템플릿, 함수 템플릿 모두 그 템플릿 들이 '사용'될 때 이다. 이 때 문법 검사도 하게 된다. 
//		템플릿을 사용하지 않았을 때는 인스턴스화가 되지 않았기에 문법 검사를 하지 않는다.
//		디버깅을 편하게 하기 위해선, 우선 일반 클래스를 만들고 테스트 해보고 템플릿화를 시키는게 좋다.

//클래스 맴버함수
//		클래스 자체는 인스턴스화 되지만, 
//		각 멤버 함수들은 템플릿 함수가 아니여도, '사용' 해야지만 인스턴스화가 된다. ***

//특수화 버전 템플릿은 언제 인스턴스화가 될까
//		역시 그 템플릿이 '사용'될 때 인스턴스화가 된다.
//		클래스의 멤버 함수가 템플릿이고, 그 템플릿의 특수화가 있다면, 상속 과정에서 모두 인스턴스화가 된다. 

//문제점
//		기본적으로 클래스 자체를 인스턴스화 해야 하기 때문에, 각 매개변수별로 한개씩 코드를 만들어 버린다. 
//		이것은 실행 파일의 크기를 크게 하여, 
//		메모리 캐쉬가 힘들어지고, 캐쉬 적중률이 낮아져 전체적인 속도를 느리게 만들 수 있다.
