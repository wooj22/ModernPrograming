//일반 함수 - 함수 템플릿 - 함수 템플릿 오버로드 - 함수 템플릿 특수화의 차이와
//인스턴스화가 발생하는 우선 순위


// 오버로드와 특수화 정리 -------------------------------------------------------------------
// 
//	C++ 함수와 마찬가지로		함수 템플릿 역시	오버로드가 가능하다.
//	C++ 클래스와 마찬가지로	클래스 템플릿은	오버로드를 할 수 없다.
//
//	특수화되지 않은 템플릿들은 기본 템플릿(primary template)이라고 한다.
//	기본 템플릿들은 특수화될 수 있다.
//
//	클래스 템플릿은 완전 / 부분 특수화가 모두 가능하나,
//	함수 템플릿은 완전 특수화만 가능하지, 부분 특수화는 불가능하다. ***
//	그러나, 함수 템플릿은 오버로드를 통해 부분 특수화와 같은 효과를 얻은 수 있다.


//우선순위 *** ------------------------------------------------------------------------------
//
//		일반 함수 >> 기본 함수 템플릿 >> 오버로드 해소 >> 특수화 함수 템플릿

//1. 비템플릿 함수들은 1급 시민이다.
//		호출문과 일치하는 매개변수 형식들을 가진 보통의 함수와 템플릿 함수가 공존하는 경우 
//		항상 보통 함수가 우선 선택된다.
// 
//2. 호출과 최소한으로도 일치하는 1급 시민(일반 함수)가 없을 경우, 
//		2급 시민이라 할 수 있는 '기본 함수 템플릿'들을 고려한다.
//		기본 함수 템플릿들이 여러 개인 경우 애매하여 판단 못함. 명시적으로 지정해야 한다.

//오버로드는 일반 함수 또는 기본 함수 템플릿들에 대해서만 적용된다. ***
//		따라서, 
//		오버로드 해소 단계에서는 특수화 함수 템플릿은 전혀 고려되지 않는다 ***



#include <iostream>
using namespace std;

// 클래스 템플릿
template<typename T>    // A
class X {};

template<typename T>    // a-1. A의 포인터 형식에 대한 부분 특수화
class X<T*> {};

template<>              // a-2. A의 int 타입에 대한 완전 특수화
class X<int> {};


// 오버로드된 두 개의 함수 템플릿
template<typename T>    // B
void function(T t) {}

template<typename T>    // C
void function(int i, T t, double d) {}

template<typename T>    // D //B와 C의 오버로드 함수. 이것은 부분 특수화가 아니다.
void function(T* t) {}

template<>              // b-1 //B의 int 타입에 대한 완전 특수화
void function<int>(int i) {}


void function(double d) {}  // B, C, D를 오버로드하는 일반 함수 (b-1은 오버로드하지 않는다)

int main() {
	bool b = true;
	int i = 0;
	double d = 0.0;

	function(b);			// B가 호출됨. B로 오버로드 해소가 되었고, T는 bool이 된다.
	function(i, 42, d);		// C가 호출됨. C로 오버로드 해소가 되었고, T는 int가 된다.
	function(&i);			// D가 호출됨. D로 오버로드 해소가 되었고, T는 int가 된다.
	function(i);			// b-1이 호출됨. B로 오버로드 해소가 되었고, 그 중 특수화된 b-1이 선택됨.
	function(d);			// double 타입의 일반 함수가 존재하므로, 당연히 1순위.
}


//다음 코드의 마지막 줄에서 호출되는 것은 어떤 f 일까? 그리고 그것이 왜 호출될까?

template<typename T>            // A
void f(T) {}

template<typename T>            // B
void f(T*) {}

template<>                      // C. A의 특수화 버전
void f<int*>(int*) {}

int main()
{
	int* p;
	f(p);                       // 어떤 f가 호출될까?		//B
}

//혼선을 피하기 위한 대안 제시 ----------------------------------------------------

template <typename T> struct FImpl; // 전방 선언

template <typename T>
void function(T t)
{
	FImpl<T>::f(t);       // 이 코드라인은 사용자가 수정하지 않는다.
}

template <typename T>     // 필요하다면 이 녀석을 특수화한다
struct FImpl {
	static void f(T t);
}

//특수화가 필요할만한 기본 함수 템플릿을 작성하는 경우,
//그것을 특수화와 오버로드가 되지 않는 기본 함수 템플릿으로 작성한 이후,
//그 함수 템플릿이 그와 동일한 시그너쳐를 가지는 정적 함수를 포함한 클래스를 이용할 것.
//그러면, 클래스를 얼마든지 자유롭게(완전/부분이든) 특수화할 수 있게 된다.