### **`borrowed ranges`와 `view`를 사용하는 이유**

C++20에서 도입된 **Ranges** 라이브러리에서 **`view`**와 **`borrowed range`**는 
성능, 메모리 사용 효율성, 코드의 가독성을 개선하는 데 중요한 역할을 합니다. 
이 두 개념은 Ranges 라이브러리를 사용할 때 특히 유용한 특성들이며, 각각의 사용 이유를 알아보겠습니다.

---

### **1. View**

**`view`**는 **"읽기 전용"** 또는 **"변환된 범위"**로, 데이터의 원본을 변경하지 않고 데이터를 **뷰(View)** 형식으로 다루는 방법입니다. 
`view`는 **메모리 사용을 최적화**하고 **효율적으로 데이터를 처리**할 수 있도록 도와줍니다.

#### **`view`의 주요 특징**
- **지연 평가 (Lazy Evaluation)**: `view`는 실제 데이터를 변경하거나 계산하지 않습니다. 대신, **필요할 때만** 데이터를 처리합니다. 
                                         즉, 실제로 데이터를 읽는 순간에만 연산이 발생하므로, 불필요한 계산을 피할 수 있습니다.
  
- **메모리 절약**: `view`는 **데이터를 복사하지 않고** 원본 데이터를 참조합니다. 
                       따라서 **추가적인 메모리 사용을 피할 수** 있어, 메모리 사용을 최적화합니다.

- **변환 가능**: `view`는 기본적으로 읽기 전용 범위이지만, 다양한 **변환 작업**(예: `filter`, `transform`)을 연속적으로 체이닝할 수 있습니다. 
                    이러한 변환은 원본 데이터를 수정하지 않고, 변환된 데이터를 **뷰(View)** 형식으로 제공합니다.

#### **`view` 사용 예시**
```cpp

#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};

    // 'view'를 사용하여 짝수만 필터링하고 각 요소를 2배로 변환
    auto even_doubled = v 
        | std::views::filter([](int x) { return x % 2 == 0; })  // 짝수만 필터링
        | std::views::transform([](int x) { return x * 2; });   // 2배 변환

    // 결과 출력
    for (int num : even_doubled) {
        std::cout << num << " ";  // 출력: 4 8
    }
}
```
- `even_doubled`는 `v`의 일부 데이터를 **뷰**로 참조하고 있으며, 원본 벡터 `v`는 변경되지 않습니다.
- 연산은 실제로 **데이터를 요청**할 때만 실행됩니다.

---

### **2. Borrowed Range**

**`borrowed range`**는 **데이터를 복사하지 않고 참조**하는 **범위**를 의미합니다. 
이는 **범위 기반 알고리즘**을 사용할 때 성능을 최적화하는 중요한 개념입니다. 
`borrowed range`는 데이터를 **복사하지 않고** 직접 참조할 수 있기 때문에, 메모리 사용을 효율적으로 처리할 수 있습니다.

#### **`borrowed range`의 주요 특징**
- **참조를 통한 메모리 절약**: `borrowed range`는 **범위의 데이터**를 **복사하지 않고 참조**하므로, 메모리 사용을 최소화할 수 있습니다. 
                                      이는 특히 대규모 데이터셋을 다룰 때 유리합니다.
  
- **성능 최적화**: 데이터가 복사되지 않으므로 **성능**을 최적화할 수 있습니다. 
                       특히, **불필요한 데이터 복사를 피하는** 방식으로 효율적인 코드 작성이 가능합니다.

- **지속적인 범위 사용**: `borrowed range`를 사용하면, **범위의 끝까지 작업을 지속**할 수 있습니다. 
                                예를 들어, 범위 내의 모든 요소를 순차적으로 처리하는 데 유리합니다.

#### **`borrowed range` 사용 예시**
```cpp

#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};

    // borrowed range를 사용하여 필터링
    auto borrowed = std::ranges::subrange(v.begin(), v.end());

    for (int num : borrowed) {
        std::cout << num << " ";  // 출력: 1 2 3 4 5
    }

    return 0;
}
```
- `borrowed`는 **`v`의 데이터 범위**를 **참조**하고 있으며, 복사 없이 해당 범위를 직접 사용합니다.
- 이 방식은 `view`와 유사하지만, 더 명시적으로 **범위를 "빌려오는"** 방식으로 메모리 사용을 최적화할 수 있습니다.

---

### **`view`와 `borrowed range`의 차이점**
- **`view`**는 **읽기 전용**으로 데이터를 참조하고, **필터링**, **변환** 등을 지원하는 **지연 평가** 방식을 제공합니다. 
                                  **뷰(View)**는 주로 데이터를 **변환하거나 처리**하는 데 유용합니다.
  
- **`borrowed range`**는 범위를 **참조**만 하고 **데이터를 수정하지 않으며**, **복사를 피하고** 메모리 효율성을 중시합니다. 
                               **범위 기반 알고리즘**에서 **참조를 사용**하는 방식으로 성능을 최적화합니다.

---

### **`view`와 `borrowed range`를 사용하는 이유**

1. **메모리 효율성**: `view`와 `borrowed range` 모두 데이터의 **복사를 방지**하고, **참조 방식**으로 메모리 사용을 최소화할 수 있습니다. 특히 **큰 데이터셋**을 다룰 때 중요합니다.

2. **성능 최적화**: 불필요한 **복사**를 피하고, **지연 평가** 방식을 통해 **실제로 필요한 시점에만 계산**이 이루어지므로 성능을 크게 향상시킬 수 있습니다.

3. **가독성 향상**: `view`를 사용하면, **파이프라인 스타일**로 **데이터를 선언적**으로 처리할 수 있습니다. 이로 인해 코드가 더 간결하고 읽기 쉽게 작성됩니다.

4. **코드 유연성**: `view`와 `borrowed range`는 **다양한 변환 작업**(예: 필터링, 변환)을 **연속적으로 적용**할 수 있게 하여, 코드의 유연성을 높입니다.

---

### **결론**

- **`view`**와 **`borrowed range`**는 **메모리 사용 최적화**, **성능 향상**, **코드 간결성**을 제공하는 중요한 도구입니다.
- `view`는 **데이터 변환과 필터링**을 지연 평가 방식으로 처리할 수 있도록 해주며, 
  `borrowed range`는 **데이터 복사를 피하고 참조를 사용하는** 방식으로 성능을 최적화합니다.
- 이 두 개념은 특히 대규모 데이터를 다룰 때 매우 유용하며, 성능을 최적화하고 **효율적인 코드**를 작성하는 데 큰 도움이 됩니다.
