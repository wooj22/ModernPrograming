

C++ **ì½”ë£¨í‹´(Coroutines)**ì€ 
*í•¨ìˆ˜ë¥¼ ì¤‘ë‹¨(suspend)í–ˆë‹¤ê°€ ë‚˜ì¤‘ì— ì¬ê°œ(resume)*í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ì–¸ì–´ ì°¨ì›ì˜ ì œì–´ íë¦„ ê¸°ëŠ¥ì…ë‹ˆë‹¤. ìŠ¤ë ˆë“œê°€ ì•„ë‹ˆë¼ ì»´íŒŒì¼ëŸ¬ê°€ ìƒíƒœ ë¨¸ì‹ ìœ¼ë¡œ ë³€í™˜í•´ ì£¼ëŠ” ê²ƒì´ í•µì‹¬ì…ë‹ˆë‹¤.

1ï¸âƒ£ ì½”ë£¨í‹´ì´ ì™œ í•„ìš”í•œê°€

	ê¸°ì¡´ ë°©ì‹ì˜ í•œê³„:
	ì½œë°± ì§€ì˜¥
	ìƒíƒœ ë¨¸ì‹  ìˆ˜ë™ êµ¬í˜„
	ìŠ¤ë ˆë“œëŠ” ë¬´ê²ê³  ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ë¹„ìš© í¼

ì½”ë£¨í‹´ì˜ ì¥ì :

	ë¹„ë™ê¸° ì½”ë“œë¥¼ ë™ê¸° ì½”ë“œì²˜ëŸ¼ ì‘ì„±
	ìŠ¤íƒë¦¬ìŠ¤(stackless) â†’ ê°€ë³ê³  ì˜ˆì¸¡ ê°€ëŠ¥
	ê²Œì„ ë£¨í”„, IO, ì„œë²„, íŒŒì´í”„ë¼ì¸ì— ë§¤ìš° ì í•©


2ï¸âƒ£ ì½”ë£¨í‹´ì„ ë§Œë“œëŠ” í‚¤ì›Œë“œ (C++20)

	ì•„ë˜ ì¤‘ í•˜ë‚˜ë¼ë„ ì“°ì´ë©´ ì½”ë£¨í‹´ì…ë‹ˆë‹¤.

	co_return
	co_await
	co_yield

	ë‹¨, ì´ í‚¤ì›Œë“œë§Œìœ¼ë¡œëŠ” ì¶©ë¶„í•˜ì§€ ì•Šê³ 
	ë°˜í™˜ íƒ€ì…ì´ ì½”ë£¨í‹´ í”„ë¡œí† ì½œì„ ë§Œì¡±í•´ì•¼ í•©ë‹ˆë‹¤.

3ï¸âƒ£ ì»´íŒŒì¼ëŸ¬ ê´€ì : ì½”ë£¨í‹´ì˜ ì‹¤ì²´

	ì½”ë£¨í‹´ í•¨ìˆ˜ëŠ” ì»´íŒŒì¼ ì‹œ:

	í•¨ìˆ˜  â†’  ìƒíƒœ ë¨¸ì‹  + í™ì— ì €ì¥ëœ coroutine frame

	ì§€ì—­ ë³€ìˆ˜ â†’ frameì— ì €ì¥
	suspend ì§€ì  â†’ ìƒíƒœ ì „ì´
	resume() â†’ switch(state)
	ğŸ‘‰ ê·¸ë˜ì„œ RAII / lifetime ì´í•´ê°€ ë§¤ìš° ì¤‘ìš”

4ï¸âƒ£ í•µì‹¬ êµ¬ì„± ìš”ì†Œ (ë©´ì ‘ ë‹¨ê³¨)

(1) promise_type

	ì½”ë£¨í‹´ì˜ â€œì»¨íŠ¸ë¡¤ íƒ€ì›Œâ€

	struct promise_type {
	    get_return_object()
	    initial_suspend()
	    final_suspend()
	    return_value / return_void
	    unhandled_exception()
	};

(2) coroutine_handle

	ì½”ë£¨í‹´ì„ ì™¸ë¶€ì—ì„œ ì œì–´í•˜ëŠ” í•¸ë“¤

	std::coroutine_handle<promise_type>
	
	resume()
	destroy()
	done()

5ï¸âƒ£ ê°€ì¥ ì‘ì€ ì½”ë£¨í‹´ ì˜ˆì œ


#include <coroutine>
#include <iostream>

struct Task {
    struct promise_type {
        Task get_return_object() {
            return {};
        }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }
        void return_void() {}
        void unhandled_exception() {}
    };
};

Task foo() {
    std::cout << "Hello ";
    co_await std::suspend_never{};
    std::cout << "Coroutine\n";
}

int main() {
    foo();
}

//co_awaitê°€ ìˆì–´ì•¼ ì½”ë£¨í‹´ìœ¼ë¡œ ë³€í™˜ë¨

6ï¸âƒ£ co_awaitì˜ ì •ì²´

	co_await exprì€ ì‚¬ì‹¤ ì•„ë˜ 3ë‹¨ê³„ë¥¼ ë”°ë¦…ë‹ˆë‹¤:

	await_ready() â†’ ë°”ë¡œ ì‹¤í–‰í• ì§€?
	await_suspend(handle) â†’ ì¤‘ë‹¨ ì‹œì 
	await_resume() â†’ ì¬ê°œ ì‹œ ë°˜í™˜ê°’

struct Awaiter {
    bool await_ready();
    void await_suspend(std::coroutine_handle<>);
    int  await_resume();
};

	ì¦‰, awaitable = ê°œë…(concept)

7ï¸âƒ£ Generator (co_yield)


#include <coroutine>

template<typename T>
struct Generator {
    struct promise_type {
        T value;
        Generator get_return_object() {
            return Generator{
                std::coroutine_handle<promise_type>::from_promise(*this)
            };
        }
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        std::suspend_always yield_value(T v) {
            value = v;
            return {};
        }
        void return_void() {}
        void unhandled_exception() {}
    };

    std::coroutine_handle<promise_type> h;
};

Generator<int> counter() {
    for (int i = 0; i < 3; ++i)
        co_yield i;
}


8ï¸âƒ£ ì‹¤ë¬´ì—ì„œ ìì£¼ í„°ì§€ëŠ” ë¬¸ì œë“¤

âŒ coroutine_handle ëˆ„ìˆ˜
	h.destroy(); // ë°˜ë“œì‹œ í•„ìš”

âŒ ì°¸ì¡° ìº¡ì²˜ ì£¼ì˜
	co_await something(x); // xê°€ í”„ë ˆì„ì— ë³µì‚¬ë˜ëŠ”ì§€ í™•ì¸

âŒ ìŠ¤ë ˆë“œ ì•ˆì „ ì°©ê°
	ì½”ë£¨í‹´ â‰  ìŠ¤ë ˆë“œ
	ìŠ¤ì¼€ì¤„ë§ì€ ì‚¬ìš©ì ì±…ì„

9ï¸âƒ£ C++ ì½”ë£¨í‹´ vs ë‹¤ë¥¸ ì–¸ì–´

ì–¸ì–´	íŠ¹ì§•
C++	ì €ìˆ˜ì¤€, ì œë¡œ ì˜¤ë²„í—¤ë“œ, ì§ì ‘ ì œì–´
C#	ëŸ°íƒ€ì„ ê´€ë¦¬, GC
Python	ì´ë²¤íŠ¸ ë£¨í”„ í•„ìˆ˜
Rust	async/await + Future trait

ğŸ‘‰ C++ì€ â€œí”„ë ˆì„ì›Œí¬ë¥¼ ë§Œë“¤ê¸° ìœ„í•œ ì½”ë£¨í‹´â€


ì‹¬í™”/ë©´ì ‘ í¬ì¸íŠ¸

	final_suspendê°€ suspend_alwaysì¸ ì´ìœ 
	symmetric transfer
	coroutine frameì˜ í• ë‹¹ ìœ„ì¹˜ (custom allocator)
	co_await vs ranges::views lazy ëª¨ë¸ ë¹„êµ
	ê²Œì„ ì„œë²„ tick ê¸°ë°˜ ì½”ë£¨í‹´ ì„¤ê³„










