템플릿 메타프로그래밍(template metaprogramming: TMP)

컴파일 도중에 실행되는 템플릿 기반의 프로그램을 작성하는 일

첫째, TMP를 쓰면 다른 방법으로는 까다롭거나 불가능한 일을 괸장히 쉽게 할 수 있습니다. 
둘째, 템플릿 메타프로그램은 C++ 컴파일이 진행되는 동안에 실행되기 때문에, 
       기존 작업을 런타임 영역에서 컴파일 타임 영역으로 전환할 수 있습니다. 

일반적으로 프로그램 실행 도중에 잡혀 왔던 몇몇 에러들을 컴파일 도중에 찾을 수 있다
파일 타임에 동작을 다 해 가지고 오기 때문에 실행 코드가 작아지고, 실행 시간도 짧아지며, 메모리도 적게 잡아먹는 것이죠
(하지만 컴파일 시간은 길어집니다).


템플릿 메타프로그래밍의 동작 원리

TMP는 그 자체가 튜링 완전성을 갖고 있는 것으로도 알려져 왔습니다. 
범용 프로그래밍 언어처럼 어떤 것이든 계산할 수 있는 능력을 갖고 있다는 뜻입니다.
"보통"의 C++에서 쓰이는 구문요소들과 꽤나 다른 모습

재귀(recursion)를 사용해서 루프의 효과를 냅니다. 
그런데 이 재귀조차도 우리가 알고 있는 종류가 아닌데, 
TMP의 루프는 재귀 함수 호출을 만들지 않고 재귀식 템플릿 인스턴스화(recursive template instantiation)를 하기 때문입니다.

template<unsigned n>   // 일반적인 경우: Factorial<n>의 값은
struct Factorial {     // Factorial<n-1>의 값에 n을 곱해서 구합니다.
    enum { value = n * Factorial<n-1>::value };
};
 
template<>             // 특수한 경우: Factorial<0>의
struct Factorial<0> {  // 값은 1입니다.
    enum { value = 1 };
};

int main()
{
    std::cout << Factorial<5>::value;   // 120을 런타임 계산 없이 출력
    std::cout << Factorial<10>::value;  // 3628800을 런타임 계산 없이 출력
}


만약 진짜 루프가 있었다면 이 값은 루프가 한 번 돌 때마다 갱신되겠지요. 
TMP는 루프 대신에 재귀식 템플릿 인스턴스화를 사용하기 때문에, 
꼬리에 꼬리를 물고 만들어지는 템플릿 인스턴스화 버전마다 자체적으로 value의 사본을 갖게 되고, 
각각의 value에는 "루프"를 한 번 돌 때 만들어지는 그 값이 담기게 되는 거죠.


템플릿 메타프로그래밍의 사용처

C++ 프로그래밍에서 TMP가 실력 발휘하는 예를 들어 보면 세 군데입니다.

치수 단위(dimensional unit)의 정확성 확인
과학 기술 분야의 응용프로그램을 만들 때는 무엇보다도 치수 단위(예를 들면 질량, 거리, 시간 등)가 똑바로 조합되어야 하는 것이 최우선입니다. 
TMP를 사용하면 계산 시간에 상관없이 프로그램 안에서 쓰이는 모든 치수 단위의 조합이 제대로 됐는지를 컴파일 동안에 맞춰 볼 수 있습니다. 
여기서 한 가지 재미있는 점은 바로 분수식 지수 표현이 지원된다는 것입니다. 
이런 표현이 가능하려면 컴파일러가 확인할 수 있도록 컴파일 도중에 분수의 약분이 되어야 합니다. 
이를테면 time^1/2는 time^4/8과 똑같이 받아들여져야 한다는 말이죠.

행렬 연산의 최적화
operator* 등의 어떤 연산자 함수는 연산 결과를 새로운 객체에 담아 반환해야 합니다. 
여러 행렬의 곱셈 결과를 "보통" 방법으로 계산하려면 여러 개의 임시 행렬이 생겨야 합니다. 
그뿐 아니라, 행렬 원소들 사이에 곱셈을 해야 하므로 여러 번의 루프가 순차적으로 만들어질 수밖에 없습니다. 
바로 이런 비싼 연산에 TMP를 응용한 고급 프로그래밍 기술인 표현식 템플릿(expression template)을 사용하면 
덩치 큰 임시 객체를 없애는 것은 물론이고 루프까지 합쳐 버릴 수 있습니다. 
게다가 기존 코드에서 문법 하나 바꾸지 않고도 이 놀라운 기술을 적용할 수 있습니다. 
이로써 우리는 메모리도 적게 먹으면서 속도는 빛나게 빠른 소프트웨어를 만들 수 있는 것이고요.

맞춤식 디자인 패턴 구현의 생성
전략(Strategy) 패턴, 감시자(Observer) 패턴, 방문자(Visitor) 패턴 등의 디자인 패턴은 그 구현 방법이 여러 가지일 수 있습니다. 
TMP를 사용한 프로그래밍 기술인 정책 기반 설계(policy-based design)라는 것을 사용하면, 
따로따로 마련된 설계상의 선택(이것을 "정책(policy)"이라고 합니다)을 나타내는 템플릿을 만들어낼 수 있게 됩니다. 
이렇게 만들어진 정책 템플릿은 서로 임의대로 조합되어 사용자의 취향에 맞는 동작을 갖는 패턴으로 구현되는 데 쓰입니다. 
이 기술에 쓰이는 예는 몇 개의 스마트 포인터 동작 정책을 하나씩 구현한 각각의 템플릿을 만들어 놓고, 
이들을 사용자가 마음대로 조합하여 수백 가지의 스마트 포인터 타입을 컴파일 도중에 생성할 수 있게 하는 것입니다. 
사실 이 기술은 디자인 패턴 혹은 스마트 포인터 등으로 대표되는 프로그래밍 구조물의 영역을 뛰어넘어 일반화되어 있는 
이른바 생성식 프로그래밍(generative programming)의 기초입니다.

TMP는 문법은 비직관적이고, 개발도구의 지원도 아주 미약하지만, 
기존 작업을 런타임에서 컴파일 타임으로 전환함으로써 손에 쥘 수 있는 놀라운 효율 향상과 
런타임에 했다면 까다롭거나 불가능했을 동작을 쉽게 표현할 수 있는 능력이 있습니다.



