컴파일러의 구현에 제한만 없다면 
	템플릿으로 무슨 계산이든 컴파일 시간에 프로그램할 수 있다. 

컴파일 시간에 세 가지 일을 할 수 있다는 사실에 뿌리가 있다.
  정수 연산을 할 수 있다 (그리고 계산된 값을 심볼로 저장할 수 있다.). 
  컴파일 시간에 결정할 수 있다.
  반복적으로 일을 할 수 있다.


템플릿 메타프로그래밍(template metaprogramming)

템플릿을 사용하는 프로그래밍 기법으로, 컴파일러에게 프로그램 코드를 생성하도록 하는 방식

메타프로그래밍 - 프로그램을 작성하는 프로그램,  코드 생성을 위한 코드 프로그래밍, 매크로, 템플릿

메타프로그래밍(Metaprogramming)이란 

자기 자신 혹은 다른 컴퓨터 프로그램을 데이터로 취급하며 프로그램을 작성·수정하는 것을 말한다. 넓은 의미에서, 런타임에 수행해야 할 작업의 일부를 컴파일 타임 동안 수행하는 프로그램을 말하기도 한다.
메타 프로그래밍에 이용되는 언어를 메타 언어라고 하고, 메타 프로그래밍의 대상이 되는 언어를 대상 언어라고 한다. 한 프로그래밍 언어가 자기 자신의 메타 언어가 되는 것을 반영이라고 한다. 메타 프로그래밍이 동작하는 방식은 세 가지 종류가 있다[출처 필요].
첫째 방식은, 런타임 엔진 코드를 API를 통해 프로그램에 노출시키는 방식이다.
둘째 방식은, 문자열이나 혹은 다른 형태로 된 프로그래밍 명령을 동적으로 수행시키는 방식이다. 둘째 방식을 이용하면 프로그램이 프로그램을 작성하게 할 수 있다[1]. 한 언어가 이 두 방식을 동시에 취할 수도 있으나, 대개의 언어들은 둘 중 한 방식으로 치우치는 경향이 있다.
셋째 방식은, 해당 언어의 범주를 완전히 벗어나는 것이다. 범용 프로그램 변환(program transformation) 시스템은 일반적인 메타프로그래밍을 직접 구현한다. 이와 같은 방식은 해당 언어에서 메타 프로그램 지원 여부와 상관없이 거의 모든 대상 언어에 적용될 수 있다.
종류에는 3가지가 있는데 타입 내성 또는 타입 자기성찰(Type Introspection), 반영(Reflection), 자기-수정 코드(Self-Modifying Code)이다. 타입 자기성찰은 수행중인 프로그램에서 변수나 함수들의 타입이나 속성을 알아내는 능력을 말한다. 반영(Reflection)은 실행중인 프로그램 자신의 구조와 행동을 조사하고 자가성찰(introspect) 하고 변경할 수 있는 능력을 말한다. 자기-수정 코드(Self-Modifying Code)는 코드를 스스로 고칠 수 있는 것을 말하는 것이다.


메타프로그래밍 기초용어

특수화(specializtion) : C++ Template 특수화를 뜻하며, 이 특수화는 메타프로그래밍의 분기(if 문 같은 거)로 많이 쓰인다. 
기본 템플릿(primary template) : 일반 C++ Template 을 뜻한다. 
인스턴스화(instantiation) : 진짜로 깨어난 코드를 말한다. 컴파일러는 깨어난 코드만 문법 검사 등을 처리 한다. 평소의 템플릿 코드는 잠자는 코드이지만, 그 잠자는 코드를 그냥 사용 했을 때, 컴파일러는 템플릿 코드를 깨워주고, 문법 검사도 해준다. 즉, 인스턴스화는 "깨어난 코드" 로 봐도 무방하다.
블로브(blob) : 클래스가 멤버함수나 멤버 값들을 가지고 있을 때, 블로브 라고 한다. 
메타 자료(metadata) : C++ Template 에서 매개변수로 쓰일 수 있는 것들을 말한다. 타입과 컴파일 타임에 알수 있는 상수가 메타자료에 속한다.
다형성(polymorphism) : 동일한 타입으로 다른 타입을 제어 할 수 있을 때, 다형성을 가진다 라고 C++ 에선 말한다. 이것은 음.. 컴파일-타임 다형성과 런-타임 다형성 두개가 있는데, 메타 프로그래밍에선 "컴파일-타임 다형성"만 사용 한다.
메타함수(metafunction) : 컴파일 타임에 호출할 수 있는 함수를 말한다. C++ 에선 클래스와 클래스 템플릿이 메타 함수이다.
수치 메타함수(numerical metafunction) : 수치 값을 벹어나는 메타함수를 뜻한다.
무항 메타함수(nullary metafunction) : 책에선 "공개적으로 접근 가능한 ::type을 가진 클래스라면 어떤 것이라도 무항 메타함수" 라 하는데, 개인적으론, 일반 클래스에 ::type이 public 으로 되어 있을 경우, 무항 메타함수라 보는게 더 좋을 듯 싶다.
특질(trait) : 이건 잘 모르겠다. 템플릿 특수화로 분기 시킨다. 이것은 연관 있다고 볼수 있다. 연관 있는것은 한가지 특징을 따르는 것이고, 이것을 특질이라고 한다. 로 내 머리속은 이해 하고 있다...
type traits : .. boost 라이브러르의 일종으로 메타 프로그래밍의 .. 산술연산 같은 녀석이다.


//템플릿 메타 - 코드를 만들어낸다.

template <int N>
struct Factorial {
  enum { value = N * Factorial<N - 1>::value };
};

template <>
struct Factorial<0> {
  enum { value = 1 };
};

int val = Factorial<2>::value;   

//코드가 컴파일되면 아래와 같은 코드를 생성한다.

struct Factorial<2> {
    enum { value = 2 * Factorial<1>::value };
};

struct Factorial<1> {
    enum { value = 1 * Factorial<0>::value };
};

struct Factorial<0> {
    enum { value = 1 };
};

//Factorial<0> 은 더 이상 Factorial<N-1>을 요구하지 않기 때문에 코드는 Factorial<0>에서 생성을 멈춘다.



